-- Legitxwx Hub v1.1.0 (Robust executor-friendly startup)
-- Put this in your executor and run

local function notify(title, text, dur)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title or "Legitxwx",
            Text = text or "",
            Duration = dur or 3
        })
    end)
end

local function safe_print(...)
    pcall(print, ...)
end

-- safe http get that tries common exploit methods and multiple URLs
local function http_get(url)
    local ok, res
    -- try game:HttpGet
    ok, res = pcall(function() return (game.HttpGet and game:HttpGet(url)) or (HttpGet and HttpGet(url)) end)
    if ok and res and #res > 0 then return res end

    -- try HttpService
    local HttpService = game:GetService("HttpService")
    ok, res = pcall(function() return HttpService:GetAsync(url) end)
    if ok and res and #res > 0 then return res end

    -- try syn.request style
    if syn and syn.request then
        ok, res = pcall(function()
            local r = syn.request({Url = url, Method = "GET"})
            return r.Body
        end)
        if ok and res and #res > 0 then return res end
    end

    -- try request (older exploits)
    if request then
        ok, res = pcall(function()
            local r = request({Url = url, Method = "GET"})
            return r.Body
        end)
        if ok and res and #res > 0 then return res end
    end

    return nil, "http_get failed for " .. tostring(url)
end

-- wrapper to try multiple windui URLs
local function load_windui()
    local urls = {
        "https://raw.githubusercontent.com/Footagesus/WindUI/main/main.lua", -- raw master
        "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua", -- releases
    }

    for _, url in ipairs(urls) do
        local body, err = http_get(url)
        if body then
            local ok, f = pcall(loadstring, body)
            if ok and type(f) == "function" then
                local ok2, ret = pcall(f)
                if ok2 and ret then
                    return ret
                elseif ok2 and not ret then
                    -- some libs return a table directly
                    return f()
                else
                    -- if the executed chunk errored, continue to next url
                    safe_print("WindUI execution error:", ret)
                end
            else
                safe_print("loadstring failed for", url, f)
            end
        else
            safe_print("http_get failed for", url, err)
        end
    end
    return nil, "Could not load WindUI from known URLs."
end

-- safe setclipboard (tries multiple executor APIs)
local function safe_set_clipboard(text)
    if not text then return false, "no text" end
    local tries = {
        function() return setclipboard(text) end,
        function() return (syn and syn.set_clipboard and syn.set_clipboard(text)) end,
        function() return (write_clipboard and write_clipboard(text)) end,
        function() return (clipboard and clipboard.set and clipboard.set(text)) end,
    }
    for _, fn in ipairs(tries) do
        local ok, res = pcall(fn)
        if ok then return true end
    end
    return false, "no clipboard method available"
end

-- top-level protected run so user sees errors
local function main()
    repeat task.wait() until game:IsLoaded()

    -- Services
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local StarterGui = game:GetService("StarterGui")
    local VirtualUser = game:GetService("VirtualUser")

    local LocalPlayer = Players.LocalPlayer

    -- FPS unlock with executor-safe check
    if type(setfpscap) == "function" or (syn and syn.set_thread_identity) or (setfflag) then
        pcall(function() if setfpscap then setfpscap(1000) end end)
        notify("Legitxwx Hub", "FPS unlock attempted.", 2)
    else
        notify("Legitxwx Hub", "setfpscap not supported by this executor.", 2)
    end

    -- load WindUI (with fallback)
    local WindUI, err = load_windui()
    if not WindUI then
        notify("Legitxwx Hub", "Failed to load WindUI. Check console.", 6)
        safe_print("WindUI load error:", err)
        return
    end

    local Window = WindUI:CreateWindow({
        Title = "Legitxwx Hub | v1.1.0",
        Icon = "door-open",
        Author = "by xwx",
        Folder = "LegitxwxHub",
        Theme = "Dark",
        Size = UDim2.fromOffset(580, 460),
        MinSize = Vector2.new(560, 350),
        MaxSize = Vector2.new(850, 560),
    })

    -- Wait for remotes but do it defensively (timeout)
    local function waitForRemote(pathParts, timeout)
        timeout = timeout or 8
        local start = tick()
        local node = game
        for i, part in ipairs(pathParts) do
            while tick() - start < timeout and not node:FindFirstChild(part) do
                task.wait(0.15)
            end
            if not node:FindFirstChild(part) then
                return nil, ("Missing %s in path"):format(part)
            end
            node = node:FindFirstChild(part)
        end
        return node
    end

    local remotesRoot, e1 = waitForRemote({"ReplicatedStorage"}, 3)
    -- Actually we want Remotes under ReplicatedStorage - try common path
    local RemotesParent = nil
    if ReplicatedStorage:FindFirstChild("Remotes") then
        RemotesParent = ReplicatedStorage:FindFirstChild("Remotes")
    else
        -- try "RemoteEvents" or "Remote" or direct names
        for _, name in ipairs({"Remotes", "RemoteEvents", "Remote"}) do
            if ReplicatedStorage:FindFirstChild(name) then
                RemotesParent = ReplicatedStorage:FindFirstChild(name)
                break
            end
        end
    end

    if not RemotesParent then
        notify("Legitxwx Hub", "Cannot find Remotes folder in ReplicatedStorage. Script will still load UI but remotes will error if used.", 6)
        safe_print("Remotes folder not found in ReplicatedStorage.")
    end

    -- try to grab individual remotes safely
    local function try_get_remote(name)
        if RemotesParent and RemotesParent:FindFirstChild(name) then
            return RemotesParent:FindFirstChild(name)
        else
            safe_print("Remote not found:", name)
            return nil
        end
    end

    local BuyGearRemote = try_get_remote("BuyGear")
    local BuyItemRemote = try_get_remote("BuyItem")
    local EquipBestBrainrotRemote = try_get_remote("EquipBestBrainrots")

    -- Lists and variables
    local gearList = {"Water Bucket","Frost Grenade","Banana Gun","Frost Blower","Carrot Launcher"}
    local seedList = {"Cactus Seed","Strawberry Seed","Pumpkin Seed","Sunflower Seed","Dragon Seed","Eggplant Seed","Watermelon Seed","Grape Seed","Cocotank Seed","Carnivorous Plant Seed","Mr Carrot Seed","Tomatrio Seed","Shroombino Seed"}

    local selectedGears, selectedSeeds = {}, {}
    local autoBuyGears, autoBuySeeds = false, false
    local autoBuyAllGears, autoBuyAllSeeds = false, false
    local gearDelay, seedDelay = 1, 1
    local autoBestBrainrot, autoBrainrotDelay = false, 60

    -- helper remotes firing that checks existance
    local function buyGear(item)
        if not BuyGearRemote then
            safe_print("BuyGear remote missing; cannot buy:", item)
            return
        end
        pcall(function() BuyGearRemote:FireServer(item) end)
    end
    local function buySeed(item)
        if not BuyItemRemote then
            safe_print("BuyItem remote missing; cannot buy:", item)
            return
        end
        pcall(function() BuyItemRemote:FireServer(item) end)
    end
    local function equipBestBrainrot()
        if not EquipBestBrainrotRemote then
            safe_print("EquipBestBrainrots remote missing; cannot equip best brainrot.")
            return
        end
        pcall(function() EquipBestBrainrotRemote:FireServer() end)
    end

    -- Anti-AFK
    pcall(function()
        LocalPlayer.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end)

    -- UI: Gears Tab
    local gearTab = Window:Tab({Title = "üåü Gears", Icon = "tool"})
    gearTab:Paragraph({Title = "Gear Shop", Desc = "Select gears and choose how to buy them."})

    gearTab:Dropdown({
        Title = "Select Gears",
        Values = gearList,
        Multi = true,
        AllowNone = true,
        Callback = function(option) selectedGears = option end
    })

    gearTab:Input({
        Title = "Gear Buy Delay (seconds)",
        Value = "1",
        Callback = function(input)
            local num = tonumber(input)
            if num and num > 0 then gearDelay = num end
        end
    })

    gearTab:Toggle({
        Title = "Auto Buy Selected Gears",
        Default = false,
        Callback = function(state)
            autoBuyGears = state
            task.spawn(function()
                while autoBuyGears do
                    for _, gear in ipairs(selectedGears) do
                        if not autoBuyGears then break end
                        buyGear(gear)
                        task.wait(gearDelay)
                    end
                    task.wait(0.25)
                end
            end)
        end
    })

    gearTab:Toggle({
        Title = "Auto Buy ALL Gears",
        Default = false,
        Callback = function(state)
            autoBuyAllGears = state
            task.spawn(function()
                while autoBuyAllGears do
                    for _, gear in ipairs(gearList) do
                        if not autoBuyAllGears then break end
                        buyGear(gear)
                        task.wait(gearDelay)
                    end
                    task.wait(0.25)
                end
            end)
        end
    })

    -- Seeds Tab
    local seedTab = Window:Tab({Title = "üå± Seeds", Icon = "leaf"})
    seedTab:Paragraph({Title = "Seed Shop", Desc = "Select seeds and choose how to buy them."})

    seedTab:Dropdown({
        Title = "Select Seeds",
        Values = seedList,
        Multi = true,
        AllowNone = true,
        Callback = function(option) selectedSeeds = option end
    })

    seedTab:Input({
        Title = "Seed Buy Delay (seconds)",
        Value = "1",
        Callback = function(input)
            local num = tonumber(input)
            if num and num > 0 then seedDelay = num end
        end
    })

    seedTab:Toggle({
        Title = "Auto Buy Selected Seeds",
        Default = false,
        Callback = function(state)
            autoBuySeeds = state
            task.spawn(function()
                while autoBuySeeds do
                    for _, seed in ipairs(selectedSeeds) do
                        if not autoBuySeeds then break end
                        buySeed(seed)
                        task.wait(seedDelay)
                    end
                    task.wait(0.25)
                end
            end)
        end
    })

    seedTab:Toggle({
        Title = "Auto Buy ALL Seeds",
        Default = false,
        Callback = function(state)
            autoBuyAllSeeds = state
            task.spawn(function()
                while autoBuyAllSeeds do
                    for _, seed in ipairs(seedList) do
                        if not autoBuyAllSeeds then break end
                        buySeed(seed)
                        task.wait(seedDelay)
                    end
                    task.wait(0.25)
                end
            end)
        end
    })

    -- Brainrots Tab
    local brainTab = Window:Tab({Title = "üß† Brainrots", Icon = "brain"})
    brainTab:Paragraph({Title = "Brainrot Auto", Desc = "Equip the best brainrot automatically or manually."})

    brainTab:Button({Title = "Equip Best Brainrot", Callback = function() equipBestBrainrot() end})

    brainTab:Input({
        Title = "Auto Collect Delay (seconds)",
        Value = "60",
        Callback = function(input)
            local num = tonumber(input)
            if num and num > 0 then autoBrainrotDelay = num end
        end
    })

    brainTab:Toggle({
        Title = "Auto Equip Best Brainrot",
        Default = false,
        Callback = function(state)
            autoBestBrainrot = state
            task.spawn(function()
                while autoBestBrainrot do
                    equipBestBrainrot()
                    task.wait(autoBrainrotDelay)
                end
            end)
        end
    })

    -- Local Tab
    local localTab = Window:Tab({Title = "üßç Local", Icon = "user"})
    localTab:Paragraph({Title = "Player Info", Desc = "Your Roblox account information:"})
    localTab:Label({Text = "Username: " .. (LocalPlayer and LocalPlayer.Name or "Unknown")})
    localTab:Label({Text = "DisplayName: " .. (LocalPlayer and LocalPlayer.DisplayName or "Unknown")})
    localTab:Label({Text = "UserId: " .. (LocalPlayer and tostring(LocalPlayer.UserId) or "Unknown")})

    localTab:Paragraph({Title = "Discord", Desc = "Copy the official Discord server link."})
    localTab:Button({
        Title = "Copy Discord",
        Callback = function()
            local ok, err = safe_set_clipboard("https://dsc.gg/9e9V648aGq")
            if ok then
                notify("Legitxwx Hub", "Discord link copied!", 2)
            else
                warn("Clipboard failed:", err)
                print("Discord link:", "https://dsc.gg/9e9V648aGq")
                notify("Legitxwx Hub", "Failed to copy. Link printed to console.", 3)
            end
        end
    })

    -- Update log
    local UPD = Window:Tab({Title = "UPD LOG", Icon = "scroll"})
    UPD:Code({
        Title = "Update Log",
        Code = [[
v1.1.0:
- Added Auto Buy ALL option for Gears & Seeds
- Fixed Brainrot auto-equip loop
- Improved FPS unlock notification
- Local tab fully functional with Discord copy fallback
- Anti-AFK included
- Script robust for multiple executors and provides debug output on failure
]]
    })

    notify("Legitxwx Hub", "Loaded successfully. Check console for details.", 3)
    safe_print("Legitxwx: Loaded OK")
end

-- run protected and show error if any
local ok, err = xpcall(main, debug.traceback)
if not ok then
    notify("Legitxwx Hub - Error", "Script failed to run. Check console for details.", 8)
    safe_print("Legitxwx startup error:", err)
end
